---
title: "[Basic] 理解SSL/TLS协议"
catalog: true
toc_nav_num: true
date: 2019-01-10 11:06:30
subtitle: "什么是SSL/TLS协议？"
header-img: "https://upload-images.jianshu.io/upload_images/1793544-35a59cc66546fe40.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"
tags:
- Basic
catagories:
- Basic
---

> 当前环境: Xcode10.0 Swift4.2 iOS SDK 12.1

前言
=======

**HTTPS原理概述**:   
`HTTP`是`HTTP协议`运行在`TCP`之上。所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。`HTTPS`是`HTTP`运行在`SSL/TLS`之上，`SSL/TLS`运行在`TCP`之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。此外客户端可以验证服务器端的身份，如果配置了客户端验证，服务器方也可以验证客户端的身份。 

```
HTTP  
|  
TCP  
```

```
HTTP  
|   
SSL/TLS  
|   
TCP
```

上面的图表示 `HTTPS`的通信是基于`SSL/TLS`上面，加密传输的。


什么是SSL/TLS协议
=======

> 本文简要介绍SSL/TLS协议的运行机制。文章的重点是设计思想和运行过程，不涉及具体的实现细节。如果想了解这方面的内容，请参阅[RFC文档](http://tools.ietf.org/html/rfc5246)。

**先概述下历史，为什么是SSL/TLS协议:**  
```
1994年，NetScape公司设计了SSL协议（Secure Sockets Layer）的1.0版，但是未发布。
1995年，NetScape公司发布SSL 2.0版，很快发现有严重漏洞。
1996年，SSL 3.0版问世，得到大规模应用。
1999年，互联网标准化组织ISOC接替NetScape公司，发布了SSL的升级版TLS 1.0版。
2006年和2008年，TLS进行了两次升级，分别为TLS 1.1版和TLS 1.2版。最新的变动是2011年TLS 1.2的修订版。
``` 
目前，应用最广泛的是`TLS 1.0`，接下来是`SSL 3.0`。但是，主流浏览器都已经实现了`TLS 1.2`的支持。
`TLS 1.0`通常被标示为`SSL 3.1`，`TLS 1.1`为`SSL 3.2`，`TLS 1.2`为`SSL 3.3`。


基本的运行过程
=======

> SSL/TLS协议的基本思路是采用`公钥加密法(非对称加密)`，也就是说，**客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。**

但是，这里有两个问题。

1. 如何保证公钥不被篡改？

    ```
    解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。
    ```

2. 公钥加密计算量太大，如何减少耗用的时间？

    ```
    解决方法：每一次对话（session），客户端和服务器端都生成一个"对话密钥"（session key），用它来加密信息。由于"对话密钥"是对称加密，所以运算速度非常快，而服务器公钥只用于加密"对话密钥"本身，这样就减少了加密运算的消耗时间。
    ```
因此，SSL/TLS协议的基本过程是这样的：

```
1.客户端向服务器端索要并验证公钥(非对称加密公钥)。
2.双方协商生成"对话密钥(对称加密密钥)"。
3.双方采用"对话密钥(对称加密密钥)"进行加密通信。

 /**然后再将对话密钥进行非对称加密。*/
```
上面过程的**前两步**，又称为"握手阶段"（handshake）。


**下面用自己的话在总结一下`HTTPS协议（不同于HTTP）`建立链接和传输过程:"**  
1. 开始握手阶段(handshake):  

    下图是握手阶段流程
    <img src="https://raw.githubusercontent.com/zColdWater/Resources/master/Images/shakehand.png" height="300" /> 

    1. 客户端发出请求（ClientHello）

        首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做ClientHello请求。
    在这一步，客户端主要向服务器提供以下信息。

        ```
        1 支持的协议版本，比如TLS 1.0版。
        2 一个客户端生成的随机数，稍后用于生成"对话密钥"。
        3 支持的加密方法，比如RSA公钥加密。
        4 支持的压缩方法。
        ```
    2. 服务器回应（SeverHello）

        服务器收到客户端请求后，向客户端发出回应，这叫做SeverHello。服务器的回应包含以下内容。

        ```
        1 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。
        2 一个服务器生成的随机数，稍后用于生成"对话密钥"。
        3 确认使用的加密方法，比如RSA公钥加密。
        4 服务器证书。
        ```
        除了上面这些信息，如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供"`客户端证书`"。比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书。

    3. 客户端回应

        客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。
如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息

        ```
        1 一个随机数。该随机数用服务器公钥加密，防止被窃听。
        2 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。
        3 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。
        ```

        上面第一项的随机数，是整个握手阶段出现的第三个随机数，又称"pre-master key"。有了它以后，客户端和服务器就同时有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把"会话密钥"。

        此外，如果前一步，服务器要求客户端证书，客户端会在这一步发送证书及相关信息。

    4. 服务器的最后回应

        服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的"会话密钥"。然后，向客户端最后发送下面信息。

        ```
        1 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。

        2 服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。
        ```

        至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的`HTTP协议`，只不过用"会话密钥"加密内容。
        


2. 基于握手阶段生成的`对话密钥`进行后续的加密通信。 




